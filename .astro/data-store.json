[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.8.0","content-config-digest","52ef0a1e0dba1217","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://denodell.com\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"never\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"experimentalLayout\":\"full-width\"},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":true,\"headingIdCompat\":false,\"preserveScriptOrder\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,56,57],"try-a-week-on-call",{"id":11,"data":13,"body":28,"filePath":29,"assetImports":30,"digest":32,"rendered":33},{"title":14,"description":15,"date":16,"author":17,"readingTime":18,"image":19,"imageAlt":20,"tags":21,"slug":11,"devToSlug":26,"utmCampaign":27},"Want to Be a Better Frontend Engineer? Try a Week On-Call","You’re going to hate me for saying this, but I actually like being on-call. Honestly! It’s taught me more about frontend quality than any bug tracker ever did.",["Date","2025-06-04T13:00:00.000Z"],"Den Odell","3 min","__ASTRO_IMAGE_./images/try-a-week-on-call.png","Developer debugging an issue with an online checkout application at 2:43 AM",[22,23,24,25],"frontend","engineering","oncall","codequality","want-to-be-a-better-frontend-engineer-try-a-week-on-call-eka","oncall_post","**You’re going to hate me for saying this, but I actually like being on-call.**  \nI know. _I know._ But hear me out.  \nObviously not the part where PagerDuty yanks you out of a dream with your heart pounding.  \nBut on-call taught me more about frontend quality than any bug tracker ever did.\n\n***\n\nIt was 2:43 AM.  \nA customer couldn’t click through to checkout.  \nRevenue was on the line.  \nAnd the alert came to me.\n\nThe root cause wasn’t in the frontend. A backend job had failed quietly, returning malformed data. But to the user, the result was simple: the button didn’t work. And when you’re on-call for the frontend, you’re the one who has to respond, no matter where the problem starts.\n\n## On-Call Sharpens What You Already Care About\n\nI’ve always cared about quality.  \nI’ve written tests, chased down edge cases, and treated polish as part of the craft.  \nBut on-call changes how you think about all of it.\n\nIt’s not just about whether your code works.  \nIt’s about how it fails.  \nIt’s about how quickly it can be understood under pressure.  \nIt’s about whether your interface can recover from issues far outside your control.\n\n## The Frontend Catches Everything\n\nWhen something fails in the system, the user usually sees it in the frontend.  \nIf a service goes down, your component gets no data.  \nIf a token expires, the user gets stuck.  \nIf a third-party script blocks rendering, your buttons stop working.  \nIf checkout breaks, your app takes the blame.\n\nYou may not control the systems upstream, but on-call teaches you that you still own the experience.\n\n## You Start Building for Real-World Failure\n\nOn-call shifts your habits.\n\nYou write clearer loading states.  \nYou handle empty, broken, or missing data.  \nYou stop assuming things will behave.  \nYou add useful logs. A _lot_ of them.  \nYou recover from failure instead of hiding from it.\n\nYou stop writing code that works in theory.  \nYou start writing code that holds up at 2 AM.\n\nYou begin asking better questions:\n- What happens if this API returns nothing?\n- What if the feature flag system is down?\n- Will this UI leave the user stranded if it doesn’t render properly?\n\n## You Build Like You’re the One Who’ll Be Paged\n\nBecause you might be.\n\nOn-call brings accountability.  \nYou stop cutting corners you know might break later.  \nYou stop leaving vague TODOs for someone else.  \nYou stop letting “it works on my machine” be the final word.\n\nA single week of on-call teaches you what months of bug triage can’t.  \nIt shows you what real-world pressure feels like, and how it exposes every weak spot in your stack.\n\nAnd once you’ve lived through that, you start building differently.  \n_You start building better._","src/content/blog/try-a-week-on-call.md",[31],"./images/try-a-week-on-call.png","7e42fbe8adee23fe",{"html":34,"metadata":35},"\u003Cp>\u003Cstrong>You’re going to hate me for saying this, but I actually like being on-call.\u003C/strong>\u003Cbr>\nI know. \u003Cem>I know.\u003C/em> But hear me out.\u003Cbr>\nObviously not the part where PagerDuty yanks you out of a dream with your heart pounding.\u003Cbr>\nBut on-call taught me more about frontend quality than any bug tracker ever did.\u003C/p>\n\u003Chr>\n\u003Cp>It was 2:43 AM.\u003Cbr>\nA customer couldn’t click through to checkout.\u003Cbr>\nRevenue was on the line.\u003Cbr>\nAnd the alert came to me.\u003C/p>\n\u003Cp>The root cause wasn’t in the frontend. A backend job had failed quietly, returning malformed data. But to the user, the result was simple: the button didn’t work. And when you’re on-call for the frontend, you’re the one who has to respond, no matter where the problem starts.\u003C/p>\n\u003Ch2 id=\"on-call-sharpens-what-you-already-care-about\">On-Call Sharpens What You Already Care About\u003C/h2>\n\u003Cp>I’ve always cared about quality.\u003Cbr>\nI’ve written tests, chased down edge cases, and treated polish as part of the craft.\u003Cbr>\nBut on-call changes how you think about all of it.\u003C/p>\n\u003Cp>It’s not just about whether your code works.\u003Cbr>\nIt’s about how it fails.\u003Cbr>\nIt’s about how quickly it can be understood under pressure.\u003Cbr>\nIt’s about whether your interface can recover from issues far outside your control.\u003C/p>\n\u003Ch2 id=\"the-frontend-catches-everything\">The Frontend Catches Everything\u003C/h2>\n\u003Cp>When something fails in the system, the user usually sees it in the frontend.\u003Cbr>\nIf a service goes down, your component gets no data.\u003Cbr>\nIf a token expires, the user gets stuck.\u003Cbr>\nIf a third-party script blocks rendering, your buttons stop working.\u003Cbr>\nIf checkout breaks, your app takes the blame.\u003C/p>\n\u003Cp>You may not control the systems upstream, but on-call teaches you that you still own the experience.\u003C/p>\n\u003Ch2 id=\"you-start-building-for-real-world-failure\">You Start Building for Real-World Failure\u003C/h2>\n\u003Cp>On-call shifts your habits.\u003C/p>\n\u003Cp>You write clearer loading states.\u003Cbr>\nYou handle empty, broken, or missing data.\u003Cbr>\nYou stop assuming things will behave.\u003Cbr>\nYou add useful logs. A \u003Cem>lot\u003C/em> of them.\u003Cbr>\nYou recover from failure instead of hiding from it.\u003C/p>\n\u003Cp>You stop writing code that works in theory.\u003Cbr>\nYou start writing code that holds up at 2 AM.\u003C/p>\n\u003Cp>You begin asking better questions:\u003C/p>\n\u003Cul>\n\u003Cli>What happens if this API returns nothing?\u003C/li>\n\u003Cli>What if the feature flag system is down?\u003C/li>\n\u003Cli>Will this UI leave the user stranded if it doesn’t render properly?\u003C/li>\n\u003C/ul>\n\u003Ch2 id=\"you-build-like-youre-the-one-wholl-be-paged\">You Build Like You’re the One Who’ll Be Paged\u003C/h2>\n\u003Cp>Because you might be.\u003C/p>\n\u003Cp>On-call brings accountability.\u003Cbr>\nYou stop cutting corners you know might break later.\u003Cbr>\nYou stop leaving vague TODOs for someone else.\u003Cbr>\nYou stop letting “it works on my machine” be the final word.\u003C/p>\n\u003Cp>A single week of on-call teaches you what months of bug triage can’t.\u003Cbr>\nIt shows you what real-world pressure feels like, and how it exposes every weak spot in your stack.\u003C/p>\n\u003Cp>And once you’ve lived through that, you start building differently.\u003Cbr>\n\u003Cem>You start building better.\u003C/em>\u003C/p>",{"headings":36,"localImagePaths":50,"remoteImagePaths":51,"frontmatter":52,"imagePaths":55},[37,41,44,47],{"depth":38,"slug":39,"text":40},2,"on-call-sharpens-what-you-already-care-about","On-Call Sharpens What You Already Care About",{"depth":38,"slug":42,"text":43},"the-frontend-catches-everything","The Frontend Catches Everything",{"depth":38,"slug":45,"text":46},"you-start-building-for-real-world-failure","You Start Building for Real-World Failure",{"depth":38,"slug":48,"text":49},"you-build-like-youre-the-one-wholl-be-paged","You Build Like You’re the One Who’ll Be Paged",[],[],{"title":14,"description":15,"date":53,"author":17,"readingTime":18,"image":31,"imageAlt":20,"tags":54,"slug":11,"devToSlug":26,"utmCampaign":27},["Date","2025-06-04T13:00:00.000Z"],[22,23,24,25],[],"table-layout-spacer-gifs",{"id":56,"data":58,"body":65,"filePath":66,"assetImports":67,"digest":69,"rendered":70},{"title":59,"description":60,"date":61,"author":17,"readingTime":18,"image":62,"imageAlt":60,"tags":63,"slug":56,"draft":64},"How We Laid Out the Web Before CSS: Tables and Spacer GIFs","",["Date","2025-06-11T13:00:00.000Z"],"__ASTRO_IMAGE_./images/table-layout-spacer-gifs.png",[22],true,"Before flex, before grid, even before float, there were tables. Not the semantic kind used for displaying tabular data — I’m talking about layout tables. And if you were building websites in the late 90s or early 2000s, you probably spent a good chunk of your time nesting them, stretching them, and stuffing them with invisible images just to get elements to line up.\n\nThis is a look back at how we used to lay out the web when CSS wasn’t quite ready — and what we can still learn from that era.\n\nHTML wasn't made for layout\nThe original purpose of HTML was to mark up academic documents. Headings, paragraphs, links, lists. That was about it. There was no real notion of \"layout\" in the design sense. Early browsers had no support for anything like positioning or styling beyond some basic font tweaks and alignment.\n\nDevelopers still wanted structure though. Clients wanted multi-column layouts, logos in the corner, and pixel-perfect buttons that looked the same in Netscape and Internet Explorer. So we did what developers always do: we got creative with what we had.\n\nEnter the layout table\nHTML tables gave us something no other element did at the time — control. You could create rows and columns. You could define cell widths and heights. You could nest tables inside other tables to carve up the page into zones. That control was intoxicating.\n\nIt wasn’t elegant. It definitely wasn’t semantic. But it worked.\n\n\u003Ctable width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n  \u003Ctr>\n    \u003Ctd width=\"200\">\n      \u003Cimg src=\"spacer.gif\" width=\"200\" height=\"1\" alt=\"\">\n    \u003C/td>\n    \u003Ctd>\n      Main content goes here\n    \u003C/td>\n  \u003C/tr>\n\u003C/table>\nSpacer GIFs like the one above were a standard trick. You'd create a 1×1 pixel transparent image, then stretch it using width and height attributes to force the browser to reserve space. There were whole toolkits and scripts that generated spacer-based layouts automatically.\n\nIf you wanted padding, you'd nest another table. If you wanted alignment, you'd add empty cells or abuse the align attribute. And when that wasn't enough, you'd resort to comment-tag hacks and conditional rendering quirks just to get things to behave consistently across browsers.\n\nWhy we did it anyway\nIt’s easy to look back now and laugh at this approach, but at the time, layout tables gave us something CSS didn’t: predictability. CSS support was spotty. Browsers implemented things inconsistently. You could spend hours writing CSS only to have it look completely broken in IE5.5. Tables weren’t perfect, but they behaved the same almost everywhere.\n\nWYSIWYG tools like Dreamweaver leaned hard into this model. You’d drag-and-drop content into table cells and the tool would spit out layers of nested HTML you were never really meant to touch.\n\nWas it bloated? Yes. Fragile? Absolutely. But it shipped.\n\nThe long road to modern CSS\nCSS1 was introduced in 1996. CSS2 followed in 1998 and gave us position: absolute, floats, and z-index. But it took years for browsers to catch up and for developers to trust it.\n\nThe table era didn’t really end until the mid-2000s when modern browsers matured and CSS layout finally became viable. Even then, it took a while before designers and developers truly embraced separation of concerns: structure in HTML, style in CSS, behavior in JavaScript.\n\nToday: grid systems, not grid hacks\nToday we have display: grid and display: flex. We can align items without nesting. We can reorder content for accessibility. We can build layouts that respond fluidly to screen size without a single spacer GIF in sight.\n\nWhat used to take 100 lines of table markup now takes 10 lines of clean, declarative CSS. It’s not just better for developers — it’s better for users too. Especially those using assistive technology, which struggled to make sense of the old markup soup.\n\nWhat this history still teaches us\nA few lessons from the table layout era still hold true:\n\nCross-browser consistency matters. Even now, not everything renders the same across platforms. Test broadly.\nYou’ll always be working with constraints. Back then, it was no CSS. Today, it might be legacy code, frameworks, or team skills. Creativity under constraint is part of the job.\nUnderstand the tools you’re misusing. Tables weren’t designed for layout, but we understood them deeply. That same mindset helps today when using any tech outside its intended sweet spot.\nIn closing\nTable-based layouts were a workaround. But they also reflect something constant about web development: we’re always adapting. Always hacking. Always building better experiences with the tools we have — until the next set of tools comes along.\n\nSo next time you float a div or write a neat little grid template, give a small nod to the table layouts that walked so Flexbox could run.","src/content/blog/table-layout-spacer-gifs.md",[68],"./images/table-layout-spacer-gifs.png","cf1b739aca28c224",{"html":71,"metadata":72},"\u003Cp>Before flex, before grid, even before float, there were tables. Not the semantic kind used for displaying tabular data — I’m talking about layout tables. And if you were building websites in the late 90s or early 2000s, you probably spent a good chunk of your time nesting them, stretching them, and stuffing them with invisible images just to get elements to line up.\u003C/p>\n\u003Cp>This is a look back at how we used to lay out the web when CSS wasn’t quite ready — and what we can still learn from that era.\u003C/p>\n\u003Cp>HTML wasn’t made for layout\nThe original purpose of HTML was to mark up academic documents. Headings, paragraphs, links, lists. That was about it. There was no real notion of “layout” in the design sense. Early browsers had no support for anything like positioning or styling beyond some basic font tweaks and alignment.\u003C/p>\n\u003Cp>Developers still wanted structure though. Clients wanted multi-column layouts, logos in the corner, and pixel-perfect buttons that looked the same in Netscape and Internet Explorer. So we did what developers always do: we got creative with what we had.\u003C/p>\n\u003Cp>Enter the layout table\nHTML tables gave us something no other element did at the time — control. You could create rows and columns. You could define cell widths and heights. You could nest tables inside other tables to carve up the page into zones. That control was intoxicating.\u003C/p>\n\u003Cp>It wasn’t elegant. It definitely wasn’t semantic. But it worked.\u003C/p>\n\u003Ctable width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n  \u003Ctbody>\u003Ctr>\n    \u003Ctd width=\"200\">\n      \u003Cimg src=\"spacer.gif\" width=\"200\" height=\"1\" alt=\"\">\n    \u003C/td>\n    \u003Ctd>\n      Main content goes here\n    \u003C/td>\n  \u003C/tr>\n\u003C/tbody>\u003C/table>\nSpacer GIFs like the one above were a standard trick. You'd create a 1×1 pixel transparent image, then stretch it using width and height attributes to force the browser to reserve space. There were whole toolkits and scripts that generated spacer-based layouts automatically.\n\u003Cp>If you wanted padding, you’d nest another table. If you wanted alignment, you’d add empty cells or abuse the align attribute. And when that wasn’t enough, you’d resort to comment-tag hacks and conditional rendering quirks just to get things to behave consistently across browsers.\u003C/p>\n\u003Cp>Why we did it anyway\nIt’s easy to look back now and laugh at this approach, but at the time, layout tables gave us something CSS didn’t: predictability. CSS support was spotty. Browsers implemented things inconsistently. You could spend hours writing CSS only to have it look completely broken in IE5.5. Tables weren’t perfect, but they behaved the same almost everywhere.\u003C/p>\n\u003Cp>WYSIWYG tools like Dreamweaver leaned hard into this model. You’d drag-and-drop content into table cells and the tool would spit out layers of nested HTML you were never really meant to touch.\u003C/p>\n\u003Cp>Was it bloated? Yes. Fragile? Absolutely. But it shipped.\u003C/p>\n\u003Cp>The long road to modern CSS\nCSS1 was introduced in 1996. CSS2 followed in 1998 and gave us position: absolute, floats, and z-index. But it took years for browsers to catch up and for developers to trust it.\u003C/p>\n\u003Cp>The table era didn’t really end until the mid-2000s when modern browsers matured and CSS layout finally became viable. Even then, it took a while before designers and developers truly embraced separation of concerns: structure in HTML, style in CSS, behavior in JavaScript.\u003C/p>\n\u003Cp>Today: grid systems, not grid hacks\nToday we have display: grid and display: flex. We can align items without nesting. We can reorder content for accessibility. We can build layouts that respond fluidly to screen size without a single spacer GIF in sight.\u003C/p>\n\u003Cp>What used to take 100 lines of table markup now takes 10 lines of clean, declarative CSS. It’s not just better for developers — it’s better for users too. Especially those using assistive technology, which struggled to make sense of the old markup soup.\u003C/p>\n\u003Cp>What this history still teaches us\nA few lessons from the table layout era still hold true:\u003C/p>\n\u003Cp>Cross-browser consistency matters. Even now, not everything renders the same across platforms. Test broadly.\nYou’ll always be working with constraints. Back then, it was no CSS. Today, it might be legacy code, frameworks, or team skills. Creativity under constraint is part of the job.\nUnderstand the tools you’re misusing. Tables weren’t designed for layout, but we understood them deeply. That same mindset helps today when using any tech outside its intended sweet spot.\nIn closing\nTable-based layouts were a workaround. But they also reflect something constant about web development: we’re always adapting. Always hacking. Always building better experiences with the tools we have — until the next set of tools comes along.\u003C/p>\n\u003Cp>So next time you float a div or write a neat little grid template, give a small nod to the table layouts that walked so Flexbox could run.\u003C/p>",{"headings":73,"localImagePaths":74,"remoteImagePaths":75,"frontmatter":76,"imagePaths":79},[],[],[],{"title":59,"description":60,"date":77,"author":17,"readingTime":18,"image":68,"imageAlt":60,"tags":78,"slug":56,"draft":64},["Date","2025-06-11T13:00:00.000Z"],[22],[]]